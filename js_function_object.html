<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
#数据类型
+ undefined:未定义

+ null:typeof(null)=object 但null并非object

+ boolean:布尔量

+ number:线性的事物，迭代和循环 NaN参与任何数值计算的结构都是NaN

+ string：字符

====================

* 简单类型都不是对象

* 所谓对象化就是可以将数据和代码组织成复杂结构的能力。

#没有类
js中没有类，类已化为无形，与对象融合为一体。（若一个生命对象开始就被规定了固定的类，那它还能演化吗？）
函数的魅力
=
function就是函数的类型
-
- 当我们写下一个函数时，只不过是建立了一个function类型的实体而已。

- 我们写的这些js函数只不过是一个命了名的变量而已，其变量类型即为function，变量的值就是我们编写的函数代码体。

- 函数就是变量，变量可以被随意赋值并用到任何地方

<code>
function mf(){alert('1')}mf();

function mf(){alert('2')}mf();


</code>
两次都会输出2，因为js是一段段分析执行程序的，而且在同一段程序的分析中，定义式的函数语句会被优先提取出来执行。

可以这样理解：
-
js中的代码也只是一种数据，同样可被任意修改复值，而他的值就是代码的逻辑。

奇妙的对象
=
函数就是对象，只不过比一般的对象多了一个（）而已，这个操作符用来执行函数的逻辑，即，函数本身还可以被调用，一般对象却不可被调用。

<code>
function sing(){
with(arguments.callee)

alert(author+poem)
}

sing.author='lb';sing.poem='hjqdy,lyzmf';sing();

sing,author='lz';sing();
</code>

##2016-06-29
#放下对象
对象天生具有自私的一面，外面的世界未经允许不可访问对象内部，当然他提供属性和方法，为他人服务。
###this
同一个函数可以从不同的角度来调用，this并不一定是函数本身所处的对象，this只是在任意对象和function预案算结合时的一个概念，在js中，可以把this看做是当前要<b>[服务]</b>的这个对象。this是一个特殊的内置参数，根据this参数，您可以访问这个对象的属性和方法，但不能给this参数赋值，
<code>
function wai(){alert(this.name+typeof(this))}

wai();//输出  object

var bg={name:'bg'};bg.wai=wai;bg.wai();//输出bg object

var sj={name:'sj'}sj.wai=wai;sj.wai()//输出sj object

//////////////////////////////

wai.call(bg)//直接将bg作为this ，调用wai,输出bg object

bg.wai.call(sj)//将sj作为this，去调用bg的wai方法，输出sj object

wai.wai=wai//将wai设置为自身的方法

wai.name='wai';
wai.wai()//此时的this是wai函数自身，输出 wai function

({name:'nbd',wai:wai}).wai()//创建一个匿名对象并设置属性后调用wai方法，输出 nbd object



</code>




























<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h1 id="">数据类型</h1>

<ul>
<li><p>undefined:未定义</p></li>
<li><p>null:typeof(null)=object 但null并非object</p></li>
<li><p>boolean:布尔量</p></li>
<li><p>number:线性的事物，迭代和循环 NaN参与任何数值计算的结构都是NaN</p></li>
<li><p>string：字符</p></li>
</ul>

<p>====================</p>

<ul>
<li><p>简单类型都不是对象</p></li>
<li><p>所谓对象化就是可以将数据和代码组织成复杂结构的能力。</p></li>
</ul>

<h1 id="">没有类</h1>

<p>js中没有类，类已化为无形，与对象融合为一体。（若一个生命对象开始就被规定了固定的类，那它还能演化吗？）</p>

<h1 id="">函数的魅力</h1>

<h2 id="function">function就是函数的类型</h2>

<ul>
<li><p>当我们写下一个函数时，只不过是建立了一个function类型的实体而已。</p></li>
<li><p>我们写的这些js函数只不过是一个命了名的变量而已，其变量类型即为function，变量的值就是我们编写的函数代码体。</p></li>
<li><p>函数就是变量，变量可以被随意赋值并用到任何地方</p></li>
</ul>

<p><code>
function mf(){alert('1')}mf();</code></p><code>

<p>function mf(){alert('2')}mf();</p>

</code><p><code></code>
两次都会输出2，因为js是一段段分析执行程序的，而且在同一段程序的分析中，定义式的函数语句会被优先提取出来执行。</p>

<h2 id="">可以这样理解：</h2>

<p>js中的代码也只是一种数据，同样可被任意修改复值，而他的值就是代码的逻辑。</p>

<h1 id="">奇妙的对象</h1>

<p>函数就是对象，只不过比一般的对象多了一个（）而已，这个操作符用来执行函数的逻辑，即，函数本身还可以被调用，一般对象却不可被调用。</p>

<p><code>
function sing(){
with(arguments.callee)</code></p><code>

<p>alert(author+poem)
}</p>

<p>sing.author='lb';sing.poem='hjqdy,lyzmf';sing();</p>

</code><p><code>sing,author='lz';sing();
</code></p>

<h2 id="20160629">2016-06-29</h2>

<h1 id="">放下对象</h1>

<p>对象天生具有自私的一面，外面的世界未经允许不可访问对象内部，当然他提供属性和方法，为他人服务。</p>

<h3 id="this">this</h3>

<p>同一个函数可以从不同的角度来调用，this并不一定是函数本身所处的对象，this只是在任意对象和function预案算结合时的一个概念，在js中，可以把this看做是当前要<b>[服务]</b>的这个对象。this是一个特殊的内置参数，根据this参数，您可以访问这个对象的属性和方法，但不能给this参数赋值，
<code>
function wai(){alert(this.name+typeof(this))}</code></p><code>

<p>wai();//输出  object</p>

<p>var bg={name:'bg'};bg.wai=wai;bg.wai();//输出bg object</p>

<p>var sj={name:'sj'}sj.wai=wai;sj.wai()//输出sj object</p>

<p>//////////////////////////////</p>

<p>wai.call(bg)//直接将bg作为this ，调用wai,输出bg object</p>

<p>bg.wai.call(sj)//将sj作为this，去调用bg的wai方法，输出sj object</p>

<p>wai.wai=wai//将wai设置为自身的方法</p>

<p>wai.name='wai';
wai.wai()//此时的this是wai函数自身，输出 wai function</p>

<p>({name:'nbd',wai:wai}).wai()//创建一个匿名对象并设置属性后调用wai方法，输出 nbd object</p>

</code><p><code></code></p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "js_function_object.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
